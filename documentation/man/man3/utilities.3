.TH "utilities" 3 "Vendredi 24 Avril 2015" "Starlight" \" -*- nroff -*-
.ad l
.nh
.SH NAME
utilities \- Diverse fonctions utilitaires de géométrie\&.  

.SH SYNOPSIS
.br
.PP
.SS "Fonctions"

.in +1c
.ti -1c
.RI "bool \fBsecondDegreeEquationSolver\fP (double, double, double, double *, double *)"
.br
.RI "\fIPermet de trouver les racines (si elles existe) d'une fonction du deuxième degré de forme $ax² + bx + c$\&. \fP"
.ti -1c
.RI "double \fBradianAsDegree\fP (const double)"
.br
.RI "\fIPermet de trouver l'angle en degré d'un angle en radian\&. \fP"
.ti -1c
.RI "double \fBradianAsDegree0to360\fP (const double)"
.br
.RI "\fIPermet de trouver l'angle en degré, entre 0 et 360, d'un angle en radian\&. \fP"
.ti -1c
.RI "bool \fBequals\fP (const double, const double, const double=\fButilities::EPSILON\fP)"
.br
.RI "\fICette méthode permet de savoir si deux double sont égaux avec une marge d'erreur Epsilon passée en paramètre ou imposée par défaut à $ \epsilon = 10^{-7}$\&. \fP"
.ti -1c
.RI "int \fBround\fP (const double)"
.br
.RI "\fICette méthode cast un double en int on l'ayant au préalable arrondi à l'unité la plus proche (0\&.5)\&. \fP"
.ti -1c
.RI "bool \fBgreaterOrEquals\fP (const double, const double, const double=\fButilities::EPSILON\fP)"
.br
.RI "\fICette méthode permet de vérifier l'inégalité $ nb_1 \geq nb_2 $ sur deux nombres réels avec une marge d'erreur Epsilon passée en paramètre ou imposée par défaut à $ \epsilon = 10^{-7}$\&. \fP"
.ti -1c
.RI "bool \fBlessOrEquals\fP (const double, const double, const double=\fButilities::EPSILON\fP)"
.br
.RI "\fICette méthode permet de vérifier l'inégalité $ nb_1 \leq nb_2 $ sur deux nombres réels avec une marge d'erreur Epsilon passée en paramètre ou imposée par défaut à $ \epsilon = 10^{-7}$\&. \fP"
.ti -1c
.RI "double \fBdegreeToRadian\fP (const double)"
.br
.RI "\fICette méthode permet de transformer des degrés en radian\&. \fP"
.ti -1c
.RI "double \fBslopeFromPoints\fP (const \fBPoint\fP &, const \fBPoint\fP &)"
.br
.RI "\fIPermet de trouver la pente d'une droite formée par deux points\&. \fP"
.ti -1c
.RI "bool \fBisHalfPiPlusNPi\fP (const double)"
.br
.RI "\fIPermet de savoir si l'angle, en radian, vaut $ \frac{\pi}{2} + n \cdot (2 \cdot \pi)$\&. \fP"
.ti -1c
.RI "double \fBtan\fP (const double)"
.br
.RI "\fIPermet d'avoir la valeur trigonométrique tangente d'un angle ou l'infini si $ angle = \frac{\pi}{2} + n \cdot 2 \cdot \pi $\&. \fP"
.ti -1c
.RI "double \fBabsoluteAngle\fP (const double)"
.br
.RI "\fIPermet d'avoir l'angle 'absolu' de celui passé en paramètre, [0, PI_2]\&. \fP"
.ti -1c
.RI "double \fBinZeroTwoPi\fP (const double)"
.br
.RI "\fIPermet de cadrer un angle dans un intervalle [0 ; 2PI[\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const double \fBPI\fP {3\&.14159265358979323846}"
.br
.RI "\fIPI Représentation de la constante PI sur 26 décimales\&. \fP"
.ti -1c
.RI "const double \fBPI_2\fP {1\&.57079632679489661923}"
.br
.RI "\fIPI_2 Représentation de la constante PI/2 sur 26 décimales\&. \fP"
.ti -1c
.RI "const double \fBPI_4\fP {0\&.785398163397448309616}"
.br
.RI "\fIPI_4 Représentation de la constante PI/4 sur 26 décimales\&. \fP"
.ti -1c
.RI "const double \fBEPSILON\fP {10E\-7}"
.br
.RI "\fIEPSILON Représentation de la marge d'erreur maximale acceptée\&. \fP"
.ti -1c
.RI "const double \fBINF\fP {1\&./0\&.}"
.br
.RI "\fIINF Représente une division impossible\&. \fP"
.in -1c
.SH "Description détaillée"
.PP 
Diverse fonctions utilitaires de géométrie\&. 
.SH "Documentation des fonctions"
.PP 
.SS "double utilities::absoluteAngle (const double)"

.PP
Permet d'avoir l'angle 'absolu' de celui passé en paramètre, [0, PI_2]\&. 
.PP
\fBRenvoie:\fP
.RS 4
L'angle absolu de celui passé en paramètre\&. 
.RE
.PP

.SS "double utilities::degreeToRadian (const double)"

.PP
Cette méthode permet de transformer des degrés en radian\&. 
.PP
\fBRenvoie:\fP
.RS 4
La valeur en radian de l'angle en degré passé en paramètre\&. 
.RE
.PP

.SS "bool utilities::equals (const double, const double, const double = \fC\fButilities::EPSILON\fP\fP)"

.PP
Cette méthode permet de savoir si deux double sont égaux avec une marge d'erreur Epsilon passée en paramètre ou imposée par défaut à $ \epsilon = 10^{-7}$\&. 
.PP
\fBParamètres:\fP
.RS 4
\fInb1\fP Un réel\&. 
.br
\fInb2\fP Un réel\&. 
.br
\fIepsilon\fP Niveau de précision souhaitée permettant de justifier l'égalité ou $ \epsilon = 10^{-7}$ par défaut\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
\fCtrue\fP Si les deux nombres sont égaux avec la précision souhaitée\&. 
.RE
.PP

.SS "bool utilities::greaterOrEquals (const double, const double, const double = \fC\fButilities::EPSILON\fP\fP)"

.PP
Cette méthode permet de vérifier l'inégalité $ nb_1 \geq nb_2 $ sur deux nombres réels avec une marge d'erreur Epsilon passée en paramètre ou imposée par défaut à $ \epsilon = 10^{-7}$\&. 
.PP
\fBParamètres:\fP
.RS 4
\fInb1\fP Un nombre réels\&. 
.br
\fInb2\fP Un nombre réels\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
\fCtrue\fP Si l'inégalité $ nb_1 \geq nb_2 $ est vérifiée\&. 
.RE
.PP

.SS "double utilities::inZeroTwoPi (const double)"

.PP
Permet de cadrer un angle dans un intervalle [0 ; 2PI[\&. 
.PP
\fBRenvoie:\fP
.RS 4
L'angle passé en paramètre dans l'intervalle [0 ; 2PI[ 
.RE
.PP

.SS "bool utilities::isHalfPiPlusNPi (const double)"

.PP
Permet de savoir si l'angle, en radian, vaut $ \frac{\pi}{2} + n \cdot (2 \cdot \pi)$\&. 
.PP
\fBRenvoie:\fP
.RS 4
\fCtrue\fP Si $ angle = \frac{\pi}{2} + n \cdot (2 \cdot \pi) $ 
.RE
.PP

.SS "bool utilities::lessOrEquals (const double, const double, const double = \fC\fButilities::EPSILON\fP\fP)"

.PP
Cette méthode permet de vérifier l'inégalité $ nb_1 \leq nb_2 $ sur deux nombres réels avec une marge d'erreur Epsilon passée en paramètre ou imposée par défaut à $ \epsilon = 10^{-7}$\&. 
.PP
\fBParamètres:\fP
.RS 4
\fInb1\fP Un nombre réels\&. 
.br
\fInb2\fP Un nombre réels\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
\fCtrue\fP Si l'inégalité $ nb_1 \geq nb_2 $ est vérifiée\&. 
.RE
.PP

.SS "double utilities::radianAsDegree (const double)"

.PP
Permet de trouver l'angle en degré d'un angle en radian\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIalpha\fP Un angle en radian\&. 
.RE
.PP
\fBRenvoie:\fP
.RS 4
L'angle exprimé en degré\&. 
.RE
.PP

.SS "double utilities::radianAsDegree0to360 (const double)"

.PP
Permet de trouver l'angle en degré, entre 0 et 360, d'un angle en radian\&. Le calcul permet d'encadrer les cas où 
.PD 0

.IP "\(bu" 2
$\alpha < 0$ 
.IP "\(bu" 2
$\alpha \geq 2\pi$ 
.IP "\(bu" 2
$0 \leq \alpha < 2\pi$ 
.PP
.PP
\fBParamètres:\fP
.RS 4
\fIalpha\fP Un angle en radian\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
L'angle exprimé en degré dans l'intervalle $[0, 360°[$ 
.RE
.PP

.SS "int utilities::round (const double)"

.PP
Cette méthode cast un double en int on l'ayant au préalable arrondi à l'unité la plus proche (0\&.5)\&. 
.PP
\fBRenvoie:\fP
.RS 4
Le nombre arrondi\&. 
.RE
.PP

.PP
Référencé par Level::getHeight(), et Level::getWidth()\&.
.SS "bool utilities::secondDegreeEquationSolver (double, double, double, double *, double *)"

.PP
Permet de trouver les racines (si elles existe) d'une fonction du deuxième degré de forme $ax² + bx + c$\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIa\fP Paramètre de x²\&. 
.br
\fIb\fP Paramètre de x\&. 
.br
\fIc\fP Terme indépendant\&. 
.br
\fIrad1\fP Pointeur vers le conteneur de la valeur de la racine obtenue avec delta positif (non utilisé s'il n'existe pas de racines)\&. 
.br
\fIrad2\fP Pointeur vers le conteneur de la valeur de la racine obtenue avec delta négatif (non utilisé s'il n'existe pas de racines)\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
\fCtrue\fP S'il existe des racines\&. 
.RE
.PP

.SS "double utilities::slopeFromPoints (const \fBPoint\fP &, const \fBPoint\fP &)"

.PP
Permet de trouver la pente d'une droite formée par deux points\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIp1\fP Un point\&. 
.br
\fIp2\fP Un point\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
La pente de l'équation de droite passant par ces deux points\&. 
.RE
.PP

.SS "double utilities::tan (const double)"

.PP
Permet d'avoir la valeur trigonométrique tangente d'un angle ou l'infini si $ angle = \frac{\pi}{2} + n \cdot 2 \cdot \pi $\&. 
.PP
\fBRenvoie:\fP
.RS 4
La tangente de l'angle ou l'infini\&. 
.RE
.PP

.SH "Documentation des variables"
.PP 
.SS "const double utilities::EPSILON {10E\-7}"

.PP
EPSILON Représentation de la marge d'erreur maximale acceptée\&. 
.PP
Définition à la ligne 30 du fichier utilities\&.hpp\&.
.SS "const double utilities::INF {1\&./0\&.}"

.PP
INF Représente une division impossible\&. 
.PP
Définition à la ligne 35 du fichier utilities\&.hpp\&.
.SS "const double utilities::PI {3\&.14159265358979323846}"

.PP
PI Représentation de la constante PI sur 26 décimales\&. 
.PP
Définition à la ligne 15 du fichier utilities\&.hpp\&.
.SS "const double utilities::PI_2 {1\&.57079632679489661923}"

.PP
PI_2 Représentation de la constante PI/2 sur 26 décimales\&. 
.PP
Définition à la ligne 20 du fichier utilities\&.hpp\&.
.SS "const double utilities::PI_4 {0\&.785398163397448309616}"

.PP
PI_4 Représentation de la constante PI/4 sur 26 décimales\&. 
.PP
Définition à la ligne 25 du fichier utilities\&.hpp\&.
.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour Starlight à partir du code source\&.
