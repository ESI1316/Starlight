.TH "Point" 3 "Vendredi 24 Avril 2015" "Starlight" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Point \- Cette classe modélise un point de coordonnés dans le plan $ R^2 $ sous deux formes :  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <point\&.hpp>\fP
.SS "Fonctions membres publiques"

.in +1c
.ti -1c
.RI "\fBPoint\fP ()=default"
.br
.RI "\fIInstancie le point $c(0, 0) p(0, 0)$\&. \fP"
.ti -1c
.RI "\fBPoint\fP (const double, const double)"
.br
.RI "\fIInstancie le point de coordonnées spécifiées\&. \fP"
.ti -1c
.RI "\fBPoint\fP (const \fBPoint\fP &)"
.br
.RI "\fIInstancie un point par copie d'un autre point : constructeur de recopie\&. \fP"
.ti -1c
.RI "double \fBgetX\fP () const "
.br
.RI "\fIRetourne l'abscisse du point\&. \fP"
.ti -1c
.RI "double \fBgetY\fP () const "
.br
.RI "\fIRetourne l'ordonnée du point\&. \fP"
.ti -1c
.RI "void \fBsetX\fP (const double)"
.br
.RI "\fIDéplace le point en l'abscisse donnée\&. \fP"
.ti -1c
.RI "void \fBsetY\fP (const double)"
.br
.RI "\fIDéplace le point en l'ordonnée donnée\&. \fP"
.ti -1c
.RI "double \fBgetRadius\fP () const "
.br
.RI "\fIPermet d'obtenir la distance séparant le point du centre de rotation\&. \fP"
.ti -1c
.RI "double \fBgetAzimut\fP () const "
.br
.RI "\fIPermet d'obtenir l'angle de la coordonnée polaire courante\&. \fP"
.ti -1c
.RI "double \fBgetAzimutAsDegrees\fP () const "
.br
.RI "\fIPermet d'obtenir l'angle de la coordonnée polaire courante exprimée en degrés\&. \fP"
.ti -1c
.RI "\fBPoint\fP & \fBrotateAround\fP (const \fBPoint\fP &, const double)"
.br
.RI "\fICette méthode change la position du point courant dans le plan par rotation autour du point cartésien passé en paramètre\&. \fP"
.ti -1c
.RI "void \fBrotate\fP (const double)"
.br
.RI "\fIEffectue une rotation autour de l'origine du plan cartésien\&. \fP"
.ti -1c
.RI "void \fBsetOrigin\fP (const \fBPoint\fP &=\fBPoint\fP{0\&., 0\&.})"
.br
.RI "\fIConsidère la position d'un point par rapport à un point quelconque\&. \fP"
.ti -1c
.RI "void \fBextend\fP (const double)"
.br
.RI "\fIModifie le point pour lui donner un position de même angle en lui ajoutant un radius\&. \fP"
.ti -1c
.RI "void \fBsetCartesianLocation\fP (const double, const double)"
.br
.RI "\fIDéplace le point en la coordonnée cartésienne donnée\&. \fP"
.ti -1c
.RI "void \fBsetPolarLocation\fP (const double, const double)"
.br
.RI "\fIDéplace le point en la coordonnée polaire donnée\&. \fP"
.ti -1c
.RI "double \fBdistanceFrom\fP (const \fBPoint\fP &) const "
.br
.RI "\fIPermet de connaitre la distance séparant le point courant d'un autre\&. \fP"
.ti -1c
.RI "\fBPoint\fP & \fBoperator=\fP (const \fBPoint\fP &)"
.br
.RI "\fIPermet de copier le contenu d'un point dans un autre point\&. \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBPoint\fP &) const "
.br
.RI "\fIPermet de savoir si deux points sont aux même endroit\&. \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBPoint\fP &) const "
.br
.RI "\fIPermet de savoir si deux points ne sont pas au même endroit\&. \fP"
.in -1c
.SS "Attributs privés"

.in +1c
.ti -1c
.RI "double \fBx\fP {0\&.}"
.br
.RI "\fIx La distance, sur l'axe des abscisses, du point par rapport à l'origine\&. \fP"
.ti -1c
.RI "double \fBy\fP {0\&.}"
.br
.RI "\fIy La distance, sur l'axe des ordonnées, du point par rapport à l'origine\&. \fP"
.ti -1c
.RI "double \fBradius\fP {0\&.}"
.br
.RI "\fIradius la distance du point par rapport à l'origine du plan cartésien\&. \fP"
.ti -1c
.RI "double \fBazimut\fP {0\&.}"
.br
.RI "\fIazimut le segment de cercle exprimé en radian depuis l'axe horizontal et dans un sens anti-horloger\&. \fP"
.in -1c
.SH "Description détaillée"
.PP 
Cette classe modélise un point de coordonnés dans le plan $ R^2 $ sous deux formes : 


.PD 0

.IP "\(bu" 2
coordonnées cartésiennes sous la forme $ c(x, y) $, 
.IP "\(bu" 2
coordonnées polaires sous la forme $ p(r, \alpha) $\&. 
.PP
Elle sert à définir la position d'un objet dans l'espace à deux dimensions\&. 
.PP
Définition à la ligne 15 du fichier point\&.hpp\&.
.SH "Documentation des constructeurs et destructeur"
.PP 
.SS "Point::Point ()\fC [default]\fP"

.PP
Instancie le point $c(0, 0) p(0, 0)$\&. 
.SS "Point::Point (const double, const double)"

.PP
Instancie le point de coordonnées spécifiées\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIx\fP l'abscisse du point 
.br
\fIy\fP l'ordonnée du point 
.RE
.PP

.SS "Point::Point (const \fBPoint\fP &)"

.PP
Instancie un point par copie d'un autre point : constructeur de recopie\&. 
.SH "Documentation des fonctions membres"
.PP 
.SS "double Point::distanceFrom (const \fBPoint\fP &) const"

.PP
Permet de connaitre la distance séparant le point courant d'un autre\&. La distance est calculée à l'aide du théorème de Pythagore au triangle rectangle : soient les deux points du plan cartésien reliés formant un segment de droite, en traçant les parallèles aux axes passant par ces points on peut délimiter un triangle rectangle par l'intersection des deux droites\&. De là, il est simple d'appliquer le théorème de Pythagore aux triangles rectangles : l'hypoténuse au carré = la somme du carré des deux autres cotés $ distance(p1, p2)^2 = (p1.x - p2.x)^2 + (p1.y - p2.y)^2 $ Dans la bibliothèque standard C++, la fonction std::hypot de <cmath> nous permet de faire cette opération en lui passant simplement les cotés autre que l'hypoténuse\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIpoint\fP Un autre point\&. 
.RE
.PP
\fBRenvoie:\fP
.RS 4
La distance séparant deux point\&. 
.RE
.PP

.SS "void Point::extend (const double)"

.PP
Modifie le point pour lui donner un position de même angle en lui ajoutant un radius\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIradius\fP Un nouveau radius\&. 
.RE
.PP

.SS "double Point::getAzimut () const\fC [inline]\fP"

.PP
Permet d'obtenir l'angle de la coordonnée polaire courante\&. 
.PP
\fBRenvoie:\fP
.RS 4
L'amplitude du point polaire courant en radian\&. 
.RE
.PP

.PP
Définition à la ligne 220 du fichier point\&.hpp\&.
.PP
Références azimut\&.
.PP
.nf
221 {
222     return this->azimut;
223 }
.fi
.SS "double Point::getAzimutAsDegrees () const"

.PP
Permet d'obtenir l'angle de la coordonnée polaire courante exprimée en degrés\&. 
.PP
\fBRenvoie:\fP
.RS 4
L'amplitude du point polaire courant en degré\&. 
.RE
.PP

.SS "double Point::getRadius () const\fC [inline]\fP"

.PP
Permet d'obtenir la distance séparant le point du centre de rotation\&. 
.PP
\fBRenvoie:\fP
.RS 4
Le rayon séparant le point polaire de son centre\&. 
.RE
.PP

.PP
Définition à la ligne 215 du fichier point\&.hpp\&.
.PP
Références radius\&.
.PP
.nf
216 {
217     return this->radius;
218 }
.fi
.SS "double Point::getX () const\fC [inline]\fP"

.PP
Retourne l'abscisse du point\&. 
.PP
\fBRenvoie:\fP
.RS 4
l'abscisse du point\&. 
.RE
.PP

.PP
Définition à la ligne 205 du fichier point\&.hpp\&.
.PP
Références x\&.
.PP
.nf
206 {
207     return this->x;
208 }
.fi
.SS "double Point::getY () const\fC [inline]\fP"

.PP
Retourne l'ordonnée du point\&. 
.PP
\fBRenvoie:\fP
.RS 4
l'ordonnée du point\&. 
.RE
.PP

.PP
Définition à la ligne 210 du fichier point\&.hpp\&.
.PP
Références y\&.
.PP
.nf
211 {
212     return this->y;
213 }
.fi
.SS "bool Point::operator!= (const \fBPoint\fP &) const"

.PP
Permet de savoir si deux points ne sont pas au même endroit\&. 
.PP
\fBRenvoie:\fP
.RS 4
\fCtrue\fP Si les deux points ne sont pas les mêmes\&. 
.RE
.PP

.SS "\fBPoint\fP& Point::operator= (const \fBPoint\fP &)"

.PP
Permet de copier le contenu d'un point dans un autre point\&. 
.PP
\fBRenvoie:\fP
.RS 4
Le point courant modifié\&. 
.RE
.PP

.SS "bool Point::operator== (const \fBPoint\fP &) const"

.PP
Permet de savoir si deux points sont aux même endroit\&. 
.PP
\fBRenvoie:\fP
.RS 4
\fCtrue\fP Si les deux points ont les même coordonnées\&. 
.RE
.PP

.SS "void Point::rotate (const double)"

.PP
Effectue une rotation autour de l'origine du plan cartésien\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIalpha\fP L'amplitude de la rotation à effectuer (en radian)\&. 
.RE
.PP

.SS "\fBPoint\fP& Point::rotateAround (const \fBPoint\fP &, const double)"

.PP
Cette méthode change la position du point courant dans le plan par rotation autour du point cartésien passé en paramètre\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIpivot\fP Le centre autour duquel le point courant doit tourner\&. 
.br
\fIalpha\fP L'amplitude de la rotation à effectuer (en radian)\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
Le point courant après rotation\&. 
.RE
.PP

.SS "void Point::setCartesianLocation (const double, const double)"

.PP
Déplace le point en la coordonnée cartésienne donnée\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIx\fP l'abscisse où déplacer le point\&. 
.br
\fIy\fP l'ordonnée où déplacer le point\&. 
.RE
.PP

.SS "void Point::setOrigin (const \fBPoint\fP & = \fC\fBPoint\fP{0\&., 0\&.}\fP)"

.PP
Considère la position d'un point par rapport à un point quelconque\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIorigin\fP La nouvelle origine du plan\&. Si ce paramètre est omis, l'origine du plan est rétabli\&. 
.RE
.PP

.SS "void Point::setPolarLocation (const double, const double)"

.PP
Déplace le point en la coordonnée polaire donnée\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIradius\fP La distance séparant le point de l'origine\&. 
.br
\fIazimut\fP L'angle, en radian, selon le cercle trigonométrique\&. 
.RE
.PP

.SS "void Point::setX (const double)"

.PP
Déplace le point en l'abscisse donnée\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIx\fP l'abscisse où déplacer le point\&. 
.RE
.PP

.SS "void Point::setY (const double)"

.PP
Déplace le point en l'ordonnée donnée\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIy\fP l'ordonnée où déplacer le point\&. 
.RE
.PP

.SH "Documentation des données membres"
.PP 
.SS "double Point::azimut {0\&.}\fC [private]\fP"

.PP
azimut le segment de cercle exprimé en radian depuis l'axe horizontal et dans un sens anti-horloger\&. 
.PP
Définition à la ligne 41 du fichier point\&.hpp\&.
.PP
Référencé par getAzimut()\&.
.SS "double Point::radius {0\&.}\fC [private]\fP"

.PP
radius la distance du point par rapport à l'origine du plan cartésien\&. 
.PP
Définition à la ligne 35 du fichier point\&.hpp\&.
.PP
Référencé par getRadius()\&.
.SS "double Point::x {0\&.}\fC [private]\fP"

.PP
x La distance, sur l'axe des abscisses, du point par rapport à l'origine\&. 
.PP
Définition à la ligne 23 du fichier point\&.hpp\&.
.PP
Référencé par getX()\&.
.SS "double Point::y {0\&.}\fC [private]\fP"

.PP
y La distance, sur l'axe des ordonnées, du point par rapport à l'origine\&. 
.PP
Définition à la ligne 29 du fichier point\&.hpp\&.
.PP
Référencé par getY()\&.

.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour Starlight à partir du code source\&.
