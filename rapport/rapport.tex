\documentclass[a4paper,11pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[pdftex]{graphicx} 
\usepackage{mathtools}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{pgf, tikz}
\usepackage{url} 
\usepackage[bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={Starlight}, 
	pdfauthor={Kriwin Paul, Placentino Simon}, pdfsubject={Starlight},
pdfkeywords={C++, ISO/IEC 14882:2011, Starlight, Projet, ESI}]{hyperref} 
\usetikzlibrary{arrows}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}
\input{./title.tex}
\tableofcontents
\chapter{Introduction}
\texttt{Starlight} est un petit jeu en deux dimensions se jouant sur une carte
rectangulaire, comportant une source de lumière, émettant un rayon rectiligne. 
Le but du jeu est d’atteindre une cible avec ledit rayon, en évitant les
obstacles via notamment des miroirs réfléchissant la lumière\footnote{tiré des
consignes du projet}.

Ce document présente les différents détails de la réalisation du projet; 
La \texttt{section 2}, décrit l'aspect formel du code (conventions de nommage, structure
des fichier etc..).

Ensuite, la \texttt{section 3} présente les classes utilisées et détaille leur contenu. 
La \texttt{section 4} décrit la structure générale du programme qui est ensuite complétée
par la \texttt{section 5} décrivant les principaux algorithmes utilisés à travers le
programme. Les sections suivantes décrivent respectivement les tests effectués
et les points bonus réalisés. Enfin la \texttt{section 9} conclut le document et est
suivit par l'annexe A contenant les références.

\section{Langage et compilation}
Ce projet a été bâti à l'aide de \textbf{Qt Creator
5.4}\footnote{voir Annexe~\ref{ref}, QT Creator}, pour l'accès à la bibliothèque
graphique, et compilé à l'aide de
\textbf{g++}\footnote{voir Annexe~\ref{ref}, GNU GCC} dans sa version 4.8 (et
compatible 4.9). La norme \textbf{ISO/IEC
14882:2011}\footnote{voir Annexe~\ref{ref}, Catalogue des normes ISO}
, aussi appelée c++11, est celle
utilisée. A cela s'ajoute certains flags\footnote{un flag est un argument de
compilation optionnel} de compilation
\begin{center}
	g++
	\textbf{-std=c++11}\textvisiblespace
	\textbf{--Wextra}\textvisiblespace
	\textbf{--Wall}\textvisiblespace
	\textbf{--pedantic-errors}
\end{center}
\begin{itemize}
	\item \textbf{-std=c++11} pour travailler en c++11,
	\item \textbf{-Wextra} qui nous permet d'avoir des messages d'avertissements
		supplémentaires (une classe non initialisée dans une classe dérivée,
		\dots),
	\item \textbf{-Wall} qui nous permet d'ajouter de nouveaux messages
		d'avertissements (ordre de la liste d'initialisation, \dots),
	\item \textbf{-pedantic-errors} qui transforme certains warnings\footnote{un
			warning n'empêche pas une bonne compilation mais demande au
		programmeur de vérifier} en erreurs.
\end{itemize}
\begin{center}
	\texttt{Ce projet est donc certifié ``Warning Free''}
\end{center}
Pour des raisons pratiques, le projet est accompagné d'un fichier de type
\textbf{Makefile}\footnote{voir Annexe~\ref{ref}, GNU MakeFile} qui s'occupe de
\begin{itemize}
	\item nettoyer le répertoire à l'aide de la commande 
		\begin{center}
			make\textvisiblespace clean
		\end{center}
	\item compiler l'ensemble du projet à l'aide de la commande
		\begin{center}
			make
		\end{center}
\end{itemize}
\newpage
\section{Documentation}
L'ensemble du projet est documenté à l'aide des balises Qt\footnote{\label{doc}voir
Annexe~\ref{ref}, Doxygen}
\begin{lstlisting}[frame=single,language=C++]
/*!
* \brief Documentation de la methode enTete
* \param Description d'un parametre
* \return Ce qui est retourne
* \see Renvoie vers une autre documentation
*/
T enTete(R param);

/*!
* \brief Documentation de la variable
*/
T variable;
\end{lstlisting}
et cette documention\textsuperscript{\ref{doc}} a est uniquement présente dans les fichiers \textbf{headers}.
La documentation, au format \LaTeX et html, a été généré à l'aide de l'outil
Doxygen\textsuperscript{\ref{doc}} dans sa dernière version
disponible\footnote{1.8.9.1}. Les spécifications de compilations sont disponible
dans le document ``doxyConfig''. La documentation
U.M.L.\footnote{voir Annexe~\ref{ref}, Unified Modeling Language} a été généré 
par l'intégration de l'outil \textbf{graphviz}\footnote{disponible dans les packages GNU/Linux -
Ubuntu standards}.
Cette documentation est disponible dans les dossiers
\begin{center}
	\path{documentation/html/index.html} \\
	\path{documentation/latex/documentation.pdf} \\
\end{center}
\section{Contenu des fichiers}
Chaque fichier contiendra les en-têtes, ou le code source, d'au maximum une seule 
classe et d'au maximum un seul namespace. Si la classe ne contient pas au moins
une classe publique, le fichier portera le nom du namespace.
Par exemple, le contenu du fichier hello.hpp peut être ainsi :
\begin{lstlisting}[frame=single,language=C++]
namespace unnamespace {class Hello {};}
\end{lstlisting}
\begin{lstlisting}[frame=single,language=C++]
namespace hello {}
\end{lstlisting}
\begin{lstlisting}[frame=single,language=C++]
class Hello {};
\end{lstlisting}
Le contenu de l'ensemble des fichiers est disponible dans le dossier
\begin{center}
	\path{src/} \\
\end{center}
\section{Fichiers}
\subsection{noms}
Le nom des fichiers est entièrement écrit en minuscule et porte le nom de la
classe, ou du namespace qu'il contient.
\subsubsection{headers}
Les headers porteront l'extension \textbf{hpp}. Ils seront disposés dans le même
dossier que leur fichier source \textbf{cpp} correspondant.
\subsubsection{sources}
Les fichiers sources porteront l'extension \textbf{cpp}. Ils seront disposé dans
le même dossier que leur fichier header \textbf{hpp} correspondant.
\subsubsection{test}
Le nom des fichiers de test est composé du nom de la classe ou du namespace
testé suivi de ``test''
\begin{lstlisting}[frame=single, mathescape, escapechar=@]
nuke.cpp $\rightarrow$ nuke@\textbf{test}@.cpp 
mirror.cpp $\rightarrow$ mirror@\textbf{test}@.cpp
\end{lstlisting}
L'ensemble de ces classes sont disponibles dans le dossier \path{test/}

\subsection{html}
Les documents \texttt{HTML}\footnote{voir Annexe~\ref{ref}, HTML sur Wikipedia} 
disponible dans \url{ressources/other} sont des textes
formatés à l'aide de \texttt{CSS}\footnote{voir Annexe~\ref{ref}, CSS sur Wikipedia}. 
Ils sont utilisés lors de l'affichage des
\textbf{règles} et du \textbf{logo}.
\subsection{niveaux}
Les fichiers de niveau qui peuvent être lu doivent être au format 
\begin{itemize}
	\item \texttt{.lvl}\footnote{Il est préférable d'utiliser celui-ci}
	\item \texttt{.mapl}
\end{itemize}

Ceux-ci sont composé de ligne significative\footnote{c'est à dire que chaque
ligne représente un objet à créer} et structurés ainsi :
\begin{itemize}
	\item taille du niveau,
	\item position de la source,
	\item position de la destination,
	\item élément du niveau,
	\item élément du niveau, \dots
\end{itemize}
Les trois premiers sont donc nécessaire au bon fonctionnement d'une partie
minimale.
\section{Nom des namespace}
Le nom d'un namespace sera exclusivement en minuscule.
\begin{lstlisting}[frame=single, language=C++]
namespace hebesi {}
\end{lstlisting}
\section{Nom des classes}
Les classes commencent toutes par une majuscule pour continuer, ensuite, en
CamelCase\footnote{\label{cc}voir Annexe~\ref{ref}, CamelCase sur Wikipedia}
\begin{lstlisting}[frame=single,language=C++]
class UneBonneClasse{};
class uneMauvaiseclasse{};
\end{lstlisting}
\section{Nom des variables}
Toutes les variables sont écrites en
\textbf{camelCase}\footnote{\ref{cc}}
\begin{lstlisting}[frame=single,language=C++]
T uneBonneVariable;
T UneMauvaiseVariable;
T uneautreMauvaisevariable;
\end{lstlisting}
et possède des noms le plus explicite possible
\begin{lstlisting}[frame=single,language=C++]
T nb; // OK
T n{38.}; // NOK
T waveLength; // OK
\end{lstlisting}
Les variables de classes possèdent le même nom que le paramètre de constructeur
qui l'initialisera. Le langage nous donne la possibilité de désambiguïser
l'utilisation de ces variables à l'aide de 
\begin{lstlisting}[frame=single,language=C++]
T var;
this->var;
\end{lstlisting}
et de la liste d'initialisation
\begin{lstlisting}[frame=single,language=C++]
UneClasse::UneClasse(T param) : param{param} {}
\end{lstlisting}
\chapter[Les classes]{Présentation succincte des classes}
\section[Les objets géométriques]{geometry}

\subsection[Ellipse]{ellipse.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[gray, very thin] (-2.1, -0.1) grid (2.1, 2.1);
		\draw[red](0, 0) -- (0, 1);
		\draw[blue](2, 1) -- (0, 1);
		\draw (0,1) ellipse (2cm and 1cm);
	\end{tikzpicture} 
\end{center}
Une ellipse\footnote{voir Annexe~\ref{ref}, Ellipse sur Wikipedia} est un objet 
géométrique à deux dimensions représentée par une courbe plane fermée obtenu par 
découpe d'un cône sur un plan. Si ce dernier est perpendiculaire à l'axe du 
cône, l'ellipse sera alors un cercle. Éléments caractéristiques d'une ellipse :
\begin{itemize}
	\item une coordonnée cartésienne, ou polaire, de son \textbf{centre} $c$,
	\item une distance séparant le centre de l'intersection avec la tangente
		parallèle à l'axe des ordonnées $x_{radius}$,
	\item une distance séparant le centre de l'intersection avec la tangente
		parallèle à l'axe des abscisses $y_{radius}$.
\end{itemize}
Ces éléments nous permettront de tracer une ellipse selon l'équation :
$$\frac{(x - c_x)^2}{{x_{radius}}^2} + \frac{(y - c_y)^2}{{y_{radius}}^2} = 1$$

Cette classe peut tout à fait être instancié en objet géométrique elliptique
et possède des méthodes d'interactions avec une droite\footnote{L'algorithme
	est disponible dans la section du même nom ou dans la documentation
accompagnant le projet}.
\begin{lstlisting}[frame=single,language=C++]
Point * Ellipse::getIntersectionsPoints(const Line &);
\end{lstlisting}
Dans le contexte présent, certains éléments du jeu seront des ellipse par le 
phénomène d'héritage mis en place dans le paradigme orienté objet de
C++\footnote{\url{http://www.tutorialspoint.com/cplusplus/cpp_object_oriented.htm}}

\subsection[Droite]{line.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[gray, very thin] (-0.1, -0.1) grid (3.1, 3.1);
		\draw[dashed] (-1, -1) -- (0, 0);
		\draw (0,0) -- (3, 3);
		\draw[dashed] (3,3) -- (4, 4);
	\end{tikzpicture} 
\end{center}
Une \texttt{droite}\footnote{voir Annexe~\ref{ref}, Droite sur Wikipedia} est une ligne 
sans épaisseur, rectiligne et infinie dans le plan. Pour exister, une droite aura besoin :
\begin{itemize}
	\item d'un coefficient angulaire $m = \frac{\Delta y}{\Delta x}$
		représentant la distance à parcourir sur l'axe des ordonnées pour une unité de
		distance sur l'axe des abscisses.
	\item d'un terme indépendant $p = \frac{y}{m \cdot x}$ représentant le décalage de chaque point
		sur l'axe des ordonnées,
	\item ou de deux points de coordonnées dans le plan $a, b$
	\item ou d'un point de coordonnées dans le plan $a$ et d'un coefficient
		angulaire $m = \frac{\Delta y}{\Delta x}$.
\end{itemize}
Ces éléments nous permettent de tracer une droite selon l'équation :
$$y = m \cdot x + p$$
Il s'agit donc de cette dernière qui a été modélisé. Pour la gestion des droites
verticales, un paramètre supplémentaire, et optionnel, a été rajouté au
constructeur. Ainsi, une méthode de la classe utilities nous permet de savoir si le
coefficient angulaire est dit ``infini'' et donc nous permettre de contenter la
demande
\begin{lstlisting}[frame=single,language=C++]
bool * Line::isVertical();
\end{lstlisting}
Ainsi, il est simple de savoir, en intérieur comme en extérieur de la classe, si
la droite est verticale ou non.\footnote{cette méthode sera utile pour trouver
	l'intersection de deux droites puisque nous n'utilisons pas la forme $ax +
bx + c = 0$} 
Il est aussi possible de savoir si un point fait parti de la droite courante.
\begin{lstlisting}[frame=single,language=C++]
bool * Line::includes(const Point &) const;
\end{lstlisting}
Cette classe peut tout à fait être instancié en objet géométrique linéaire
et possède des méthodes d'interactions avec d'autres droites\footnote{L'algorithme
	est disponible dans la section du même nom ou dans la documentation
accompagnant le projet}.
\begin{lstlisting}[frame=single,language=C++]
Point * Line::getIntersectionPoint(const Line &);
\end{lstlisting}
Dans le contexte présent, certains éléments du jeu seront des droites par le 
phénomène d'héritage mis en place dans le paradigme orienté objet de
C++\footnote{\url{http://www.tutorialspoint.com/cplusplus/cpp_object_oriented.htm}}
\subsection[Rectangle]{rectangle.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw (1, 1) -- (4, 1);
		\draw (4, 1) -- (4, 2.5);
		\draw (4, 2.5) -- (1, 2.5);
		\draw (1, 2.5) -- (1, 1);
	\end{tikzpicture} 
\end{center}
Un rectangle\footnote{voir Annexe~\ref{ref}, Rectangle sur Wikipedia}  est une forme géométrique à 4 segments de droite\footnote{Un
	segment de droite est une partie de droite délimitée par deux points non
confondus} 
parallèle deux à deux.Ceux-ci vont donc former 4 angles droit ($\frac{\pi}{2} rad$)
Cette forme peut être représentée par :
\begin{itemize}
	\item la coordonnée du coin supérieur gauche $Sg = (x, y)$
	\item la grandeur des deux segments formant un angle de $\frac{\pi}{2} rad$
		en ce point $hauteur$ et $largeur$.
\end{itemize}

Ainsi, il sera aisé de déterminer la position des autres coins 
\begin{itemize}
	\item $Sd = (Sg_x + largeur, Sg_y)$
	\item $Ig = (Sg_x , Sg_y + hauteur)$
	\item $Id = (Sg_x + largeur, Sg_y + hauteur)$
\end{itemize}
et de modéliser le rectangle à l'aide de 4 équations de droite, les objets Line.
Cette classe peut tout à fait être instancié en objet géométrique rectangulaire
et possède des méthodes d'interactions avec d'autres droites\footnote{L'algorithme
	est disponible dans la section du même nom ou dans la documentation
accompagnant le projet}.
\begin{lstlisting}[frame=single,language=C++]
vector<Point> Rectangle::getIntersectionPoints(Line &);
\end{lstlisting}
\subsection[Point]{point.hpp}
Un point\footnote{voir Annexe~\ref{ref}, Point sur Wikipedia}  est un objet mathématique permettant de situer un élément dans un plan
ou dans l'espace. Dans notre cas, plus spécifiquement dans un plan à deux
dimensions. Celui-ci peut-être représenté de plusieurs manières dans le plan 
cartésien{voir Annexe~\ref{ref}, Plan cartésien} : 
\begin{itemize}
	\item sous la forme d'une coordonnées cartésienne à l'aide de 
		\begin{itemize}
			\item une origine, $$(0, 0)$$
			\item deux vecteurs partant de cette origine et perpendiculaires,
				$$P = (\vec{x}, \vec{y})$$
		\end{itemize}
	\item et sous la forme d'une coordonnée polaire à l'aide de
		\begin{itemize}
			\item une origine, $$(0, 0)$$
			\item une coordonnée radiale, $$r \in \mathbb{R}$$
			\item une coordonnée angulaire, $$\alpha \in \mathbb{R}$$
		\end{itemize}
\end{itemize}
\subsection[Utilitaire]{utilities.hpp}
Le namespace \texttt{utilities} mis en place ici est un ensemble de fonctions et valeurs
constantes spécifiquement définies pour les calculs intervenant dans le projet.

\subsubsection{constantes :}
\begin{description}
	\item[PI] est un approximation de $\pi$ sur 26 décimales,
	\item[PI\_2] est une approximation de $\frac{\pi}{2}$ sur 26 décimales,
	\item[PI\_4] est une approximation de $\frac{\pi}{4}$ sur 26 décimales,
	\item[EPSILON] est une marge d'erreur de $10^{-7}$,
	\item[INF] représente un nombre dit ``infini'' dans le milieu informatique.
\end{description}
\subsubsection{fonctions :}
\begin{lstlisting}[title=Resolution d'équation du second degre,frame=single,language=C++]
utilitaire::secondDegreeEquationSolver
\end{lstlisting}
\begin{lstlisting}[title=Transforme un angle exprime en radian en un angle
exprime en degres,frame=single,language=C++]
utilitaire::angleAsDegree
\end{lstlisting}
\begin{lstlisting}[title=Permet de tester l egalite ou l inegalite entre deux 
nombre reels a un Epsilon d erreur,frame=single,language=C++]
utilitaire::equals
utilitaire::greaterOrEquals
utilitaire::lessOrEquals
\end{lstlisting}
\begin{lstlisting}[title=Permet de trouver le coefficiant angulaire a partir de deux points,frame=single,language=C++]
utilitaire::slopeFromPoints
\end{lstlisting}
\begin{lstlisting}[title=Permet de trouver la valeur tangante d'un angle 
	en radian mais aussi de retourner une valeur particuliere pour la tangante de
$\pi/2$,frame=single,language=C++]
utilitaire::tan
\end{lstlisting}
\begin{lstlisting}[title=Permet de savoir si $\alpha$ vaut  $\frac{\pi}{2} + n *
\pi\ n \in \mathbb{N}$,frame=single,language=C++]
utilitaire::isHalfPiPlusNPi
\end{lstlisting}

Pour d'autres informations, consultez la documentation générée.
\section[Les éléments]{éléments}
\subsection[Element]{element.hpp}
Cette classe, abstraite et donc non instanciable, représente un élément du jeu
lié à un, et un seul, niveau du jeu. Cette classe permet donc d'établir une
communication entre les différents éléments du niveau et le niveau lui-même à
travers un référencement de ce dernier.
Par le phénomène d'héritage, chaque élément se devra d'établir sa manière propre de
réagir avec le niveau en lui exprimant : 
\begin{itemize}
	\item ses points d'intersection avec un rayon si il lui sont demandés,
		\begin{lstlisting}[language=C++]
		Element::includeRay(Ray);
		\end{lstlisting}
	\item les actions à effectuer si un contact avec le rayon a eu lieu.
		\begin{lstlisting}[language=C++]
		Element::reactToRay(Ray);
		\end{lstlisting}
\end{itemize}
Il sera donc aisé pour le niveau de gérer les collisions des éléments de manière
anonyme et optimale.
\subsection[Cristal]{crystal.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[fill=green] (0,0) ellipse (2cm and 2cm);
		\draw[yellow] (-4, 0) -- (-2, 0);
		\draw[red] (2, 0) -- (3, 0);
	\end{tikzpicture} 
\end{center}
Cette classe est, par héritage, un élément ainsi qu'une ellipse. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et communique avec
le niveau auquel il est lié. 

Le cristal modifie la longueur d'onde d'un rayon qui le traverse en lui
augmentant ou en lui diminuant sa longueur d'onde. Il en devient nécessaire à la
réussite d'une partie de jeu puisque les éléments \texttt{lens} requiert un
rayon de longueur d'onde particulière. Puisque le rayon est visible il se doit
de respecter le spectre lumineux visible $IR < wl < UV$ et donc un dépassement
par le haut ou par le bas après amplification sera rétabli à la valeur logique 
la plus proche.
\subsection[Destination]{dest.hpp}
Cette classe est, par héritage, un élément ainsi qu'un rectangle. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. 

La destination est le but du jeu et l'atteindre terminera automatiquement la 
partie sur une victoire. La longueur d'onde du rayon n'a aucun importance.
\subsection[Lentille]{lens.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[fill=blue,blue] (0,0) ellipse (2cm and 1cm);
		\draw[red] (-4, 0) -- (-2, 0);
		\draw[red, dashed] (2, 0) -- (3, 0);
	\end{tikzpicture} 
\end{center}
Cette classe est, par héritage, un élément ainsi qu'un rectangle. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. La lentille est un éventuel
obstacle à un rayon puisqu'il ne le laissera passer que si la longueur d'onde de
ce dernier respecte le critère
$$lens_{min} \leq ray_{\alpha} \leq lens_{max}$$

Deux issues sont alors possible :
\begin{itemize}
	\item la longueur d'onde entre dans l'intervalle et le rayon est renouvelé
		après la lentille,
	\item elle ne rentre pas dans l'intervalle défini et le rayon sera terminé par
		la lentille
\end{itemize}
et ce même si le rayon tiré est tangent à la lentille. En effet, si la droite
représentant le rayon est tangent à l'ellipse représentant la lentille,
un point d'intersection existe entre les deux. Il est donc de ce point d'agir
comme l'aurait fait l'entière lentille à tout autre point même si cette
réaction particulière peut être discutable. 

\subsection[Miroir]{mirror.hpp}
Cette classe est, par héritage, un élément ainsi qu'une droite. Le miroir peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communiquer avec le niveau auquel il est lié. Le miroir est, plus précisément,
un segment de droite délimité par deux points. Puisque le miroir effectue une
rotation autour d'un point $p \in mirroir$, il n'est pas directement
délimité par ses deux extrémités mais bien par sa longueur, son angle, la position
absolue (cartésienne) et relative (distance par rapport à une extrémité)
de son point de rotation qui définissent, dynamiquement, ses points délimiteurs.
Pour trouver les deux points il suffit de :
\begin{enumerate}
	\item extrémité gauche = ($x_{pivot}$ - position absolue, $y_{pivot}$)
	\item extrémité droite = ($x_{gauche}$ + taille du segment, $y_{pivot}$)
	\item rotation des deux extrémité autour du point de pivot.
\end{enumerate}
\subsection[Bombe]{nuke.hpp}
Cette classe est, par héritage, un élément ainsi qu'une ellipse. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. La bombe est une ellipse
particulière puisqu'elle possède un $x_{radius} = y_{radius}$ lui donnant comme
caractéristique d'être un cercle. Cet objet circulaire est l'objet à éviter lors
d'une partie puisqu'il amène directement à la fin d'une partie.

\subsection[Rayon]{ray.hpp}
Cette classe est, par héritage, une droite. Ce rayon représente l'ensemble des
points parcouru par un rayon laser et subit les interactions de son
environnement comme dans la vie réelle :
\begin{itemize}
	\item il sera reflété par un miroir selon le principe de réflexion
		$\alpha_{i} = \alpha_{r}$,
	\item il sera arrêté par les objets opaques (murs, source, destination).
\end{itemize}

Le rayon déclenche les réactions des éléments du jeu via la méthode
\texttt{reactToRay} des héritiers d'Element.

\subsection[Source]{source.hpp}
Cette classe est, par héritage, un élément ainsi qu'un rectangle. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. 

La source est le point d'émission du tout premier rayon du jeu selon un sens 
et une direction définis dans le fichier de niveau. Celui-ci ne peut être
modifié directement en jeu. La source n'existe pas, c'est à dire qu'elle n'a
aucun effet sur les rayons et les rayons n'ont aucun effet sur elle.

\subsection[Mur]{wall.hpp}
Cette classe est, par héritage, un élément ainsi qu'une droite. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. Le mur est défini par deux points
qui en font un segment de droite. Il est un objet fixe du jeu qui arrête un
rayon et lui défini un point qui le transforme en segment de droite.

\subsection[Niveau]{level.hpp}
Le level est une classe qui est composée et qui s'occupe de gérer l'ensemble des
éléments du jeu au niveau ``business''.

Celui-ci va donc recevoir les communications de ses éléments et agir en
conséquence à l'aide de fonction récursive croisée 
\begin{lstlisting}[language=C++]
void computeRay(Ray);
void computeRays();
\end{lstlisting}

En effet, puisque la source créé un rayon dans le niveau, celui-ci va s'occuper
de demander à chaque élément qui interagit avec le rayon précédent ce qui se
passera ensuite et à partir de là, une réaction ``boule de neige'' se fera
jusqu'à l'intersection d'un élément arrêtant le processus.
\subsection[Createur de niveau]{levelfactory.hpp}
Le créateur de niveau est un \texttt{namespace} de méthodes qui va s'occuper de lire
les données des éléments dans un fichier. 
Pour ce faire, il s'occupera de lire chaque type d'objet selon des règles
différentes :
\begin{lstlisting}[frame=single,language=C++]
levelFactory::getSource;
levelFactory::getDestination;
levelFactory::getCrystal;
levelFactory::getLens;
levelFactory::getNuke;
levelFactory::getWall;
levelFactory::getMirror;
\end{lstlisting}
\section[L'exception]{exception}
\subsection[Exception Starlight]{starlightexception.hpp}
Il est nécessaire, pour bon nombre des classes créées, de valider les arguments passés en
paramètre dans le but de ne pas produire d'objets incohérents par rapport à
l'analyse préalable du travail à fournir. Pour ce faire, des exceptions doivent
être levées quand une instanciation créera un objet non désiré. 
Cette classe hérite de std::exception appartenant à la librairie standard. Elle n'a aucune
capacité supplémentaire mise à part être spécifique à ce projet. \\ \\

Les différentes classes pouvant lever cette exception sont :
\begin{description}
	\item[crystal] si la taille de son rayon ne lui permet pas d'exister dans le
		plan,
	\item[lens] si son intervalle de longueur d'onde n'est pas cohérent,
	\item[level] si ses dimensions ne lui permettent pas d'exister dans le plan,
	\item[mirror] si ses dimensions ne lui permettent pas d'exister dans le
		plan, si sa position ou son angle n'entre pas dans les limites imposées,
	\item[nuke] si la taille de son rayon ne lui permet pas d'exister dans le
		plan,
	\item[ray] si sa longueur d'onde n'entre pas dans l'intervalle cohérent
		imposé,
	\item[source] si sa longueur d'onde n'entre pas dans l'intervalle cohérent
		imposé,
	\item[wall] si ses points déterminants ne lui permettent pas d'exister dans
		le plan,
	\item[ellipse] si ses dimensions ne lui permettent pas d'exister dans le
		plan,
	\item[rectangle] si ses dimensions ne lui permettent pas d'exister dans le
		plan.
\end{description}
\newpage
\section[Les objets visuels]{view}
La vue du jeu est constituée de trois éléments;
\begin{itemize}
	\item \texttt{MainMenu} (widget),
	\item \texttt{LevelView} (widget),
	\item \texttt{la fenêtre principale} (MainWindow),
\end{itemize}
cette dernière s'occupe d'alterner l'affichage des deux premiers.

\begin{enumerate}
	\item[] Ces éléments graphiques peuvent être classés en 3 catégories :
	\item \texttt{éléments statiques} : 
		N'étant pas directement manipulés par l'utilisateur, ces derniers représentent
		les éléments du niveau dont \textbf{l'affichage ne varie pas} au cours de la partie. Il
		s'agit des murs du niveaux (QGraphicsLineItems\textsuperscript{\ref{qgs}}), des lentilles, bombes,
		cristaux (QGraphicsEllipseItem\textsuperscript{\ref{qgs}}) et de la destination
		(QGraphicsRectItem\textsuperscript{\ref{qgs}}).
		Ces éléments sont construit au chargement du fichier de niveau grâce à
		des méthodes utilitaires contenues dans viewUtilities.hpp. 
		Ils ne sont jamais mis à jours et sont détruits lorsque un nouveau niveau est
		chargé. 

		\begin{figure}[h!]
			\caption{Un cristal.}
			\includegraphics{./screenshots/elements_statiques/crystal}
		\end{figure}
		\begin{figure}[h!]
			\caption{Une destination.}
			\includegraphics{./screenshots/elements_statiques/dest}
		\end{figure}
		\begin{figure}[h!]
			\caption{Une lentille.}
			\includegraphics{./screenshots/elements_statiques/lens}
		\end{figure}
		\begin{figure}[h!]
			\caption{Une bombe.}
			\includegraphics{./screenshots/elements_statiques/nuke}
		\end{figure}
		\begin{figure}[h!]
			\caption{Un mur.}
			\includegraphics{./screenshots/elements_statiques/wall}
		\end{figure}
	\newpage
	\item \texttt{Semi dynamiques} : 
		Il s'agit de l'affichage des rayons à partir de QGraphicsLineItems\textsuperscript{\ref{qgs}} dont la
		couleur varie selon la longueur d'onde du rayon représenté. Ils sont construits
		grâce à des méthodes utilitaires contenues dans viewUtilities.hpp et
		détruits à chaque modification de l'état du niveau. 

		\begin{figure}[h!]
			\caption{Un rayon changeant de couleur.}
			\centering
			\includegraphics[keepaspectratio=true,width=0.2\linewidth]{./screenshots/elements_semi_dyn/ray_change_color}
		\end{figure}

	\item \texttt{dynamiques} :
		Ce sont les élément permettant de \textbf{recueillir les entrées
		utilisateur} et dont l'affichage évolue en fonction de l'état du niveau.

		\begin{figure}[h!]
			\caption{La source éteinte.}
			\centering
			\includegraphics{./screenshots/elements_dyn/source_off}
		\end{figure}
		\begin{figure}[h!]
			\caption{La source allumée.}
			\centering
			\includegraphics{./screenshots/elements_dyn/source_on}
		\end{figure}
\end{enumerate}

\subsection[La source]{sourceview.hpp}
Cette classe représente la source sous l'état d'un \texttt{QGraphicsRectItem}, contenant
un QRectF aux dimensions de la source. Il peut donc être utilisé dans un 
QGraphicsScene. Il est, donc, \texttt{lié à la source} et se met uniquement à jour 
lors d'une interaction de l'utilisateur (clic de souris). De plus, il interagit
avec le modèle pour changer l'état de la source.

Il s'agit d'un objet héritant de QGraphicsRectItem\textsuperscript{\ref{qgs}} représentant la source
lumineuse du niveau. Il permet lorsque l'utilisateur clique dessus, 
d'allumer/éteindre la source du niveau et ainsi provoquer la présence ou 
l'absence des rayons dans le niveau.\footnote{\textit{il émet un son et change sa couleur selon que l'on allume ou
éteint la source.}}


\subsection[Le miroir]{mirrorview.hpp}
Il s'agit d'un objet héritant de QGraphicsLineItem\textsuperscript{\ref{qgs}} représentant un miroir du
niveau. Il permet une fois sélectionné en ayant cliqué dessus, de \texttt{faire
dévier} les rayons l'atteignant en fonction des mouvements que l'utilisateur exercera 
sur lui :\footnote{voir Annexe~\ref{ref}, commandes du jeu}.
\begin{itemize}
	\item touches pour le déplacer 
	\item et flèches directionnelles pour le faire pivoter
\end{itemize}

		\begin{figure}[h!]
			\caption{Un miroir.}
			\centering
			\includegraphics[keepaspectratio=true,width=0.2\linewidth]{./screenshots/elements_dyn/mirror}
		\end{figure}

		\begin{figure}[h!]
			\caption{Un miroir et un rayon réfléchi.}
			\centering
			\includegraphics[keepaspectratio=true,width=0.2\linewidth]{./screenshots/elements_dyn/mirror+ray}
		\end{figure}
		\newpage
\subsection[Le niveau]{levelview.hpp}
Il s'agit d'un \textbf{widget} hérité de QGraphicsView (utilisant, en son sein,le
framework du même nom\footnote{\label{qgv}voir Annexe~\ref{ref}, Qt GraphicsView
Framework}), s'occupant de l'affichage du niveau, de la réception
des entrées utilisateur et de l'interaction entre celles-ci et la partie
métier. 

Cette vue met en œuvre le patron de conception \texttt{Observateur Observé} initié par
la partie métier (classe Level), de sorte qu'elle se contente seulement de
mettre à jour l'affichage de l'état du niveau lorsqu'elle est notifiée de le
faire par celui-ci. 

Cette vue comporte une QGraphicScene\footnote{\label{qgs}voir Annexe~\ref{ref},
Qt QGraphicScene} qui elle-même comporte des éléments graphiques 
(QGraphicItems\textsuperscript{\ref{qgs}}) représentant les différents éléments contenus
dans le niveaux. 

\begin{figure}[h!]
	\caption{Un LevelView.}
	\centering
	\includegraphics[keepaspectratio=true,width=0.7\linewidth]{./screenshots/level_view}
\end{figure}

\subsection[Le menu]{mainmenu.hpp}
Ce widget héritant de \textbf{QFrame} représente le menu principale du jeu. Il s'agit de
la première fenêtre qui apparait à l'utilisateur lorsque l'on lance le
programme. 

Cette fenêtre propose à travers de \textbf{QPushButtons}, diverses option
telles que; 
\begin{itemize}
	\item choisir un fichier de niveau (et ainsi démarrer une partie),
	\item consulter les règles du jeu (s'affichant dans une boîte de dialogue) 
	\item ou quitter le jeu (arrête le programme).
\end{itemize}

\begin{figure}[h!]
	\caption{Un menu principal.}
	\centering
	\includegraphics[keepaspectratio=true,width=0.7\linewidth]{./screenshots/main_menu}
\end{figure}
\begin{figure}[h!]
	\caption{Affichage des règles.}
	\centering
	\includegraphics[keepaspectratio=true,width=0.5\linewidth]{./screenshots/rules}
\end{figure}

\subsection[La fenêtre principale]{mainwindow.hpp}

Il s'agit de la \textbf{fenêtre principale} du programme qui s'occupe d'alterner
l'affichage du menu principal du jeu et l'affichage d'une partie. Elle permet
également de proposer une barre d'outils durant l'affichage d'une partie
permettant de
\begin{itemize}
	\item recommencer le niveau en cours, revenir au menu principal,
	\item quitter le jeu ou connaitre les règles du jeu.
\end{itemize}

\newpage
L'alternance de l'affichage est mis en œuvre grâce au mécanisme des
signaux et \texttt{slots}\footnote{voir Annexe~\ref{ref}, Signals and Slots}
En effet MainWindow propose deux slots 
\begin{lstlisting}[title=MainWindow,frame=single,language=C++]
public slots :

/* Permet d'afficher la vue du niveau. */
void MainWindow::displayLevel 

/* Permet d'afficher le menu principal. */
void MainWindow::displayMainMenu 
\end{lstlisting}
Ces slots sont par défaut connectés\footnote{voir Annexe~\ref{ref},
QObject::connect dans Signals and slots} aux signaux 
\begin{lstlisting}[title=LevelView,frame=single,language=C++]
public signals : 
void displayingStarted();
void displayingStopped();
\end{lstlisting}
Ainsi lorsque que l'utilisateur a sélectionné l'action de revenir au menu
principal (à partir de la barre d'outils ou à partir de la boite de dialogue à
la fin d'une partie), 

\begin{enumerate}
	\item la vue de niveau envoie le signal correspondant
	\item cette dernière va ensuite \textbf{cacher la vue de niveau} et afficher le menu principal,
		(\texttt{displayingStopped()}) à la MainWindow auquel elle se rapporte, 
\end{enumerate}

Il en va de même pour afficher la vue du niveau, 
\begin{enumerate}
	\item le signal newLevelFileSelected de MainMenu étant connecté au slot
		\texttt{setLevelFilePath()}),
	\item ce dernier émet ensuite le signal \texttt{displayingStarted()}), 
	\item lorsque l'utilisateur choisi un fichier de niveau, la vue du
		menu principal va ainsi laisser place à la vue du niveau.
\end{enumerate}

\chapter[Algorithmes]{Détail des algorithmes utilisés}
\section[Réflexion]{Algorithme de réflexion}
\input{./reflexion.tex} \\
$\alpha$ l'angle du nouveau rayon \\
$\beta$ l'angle du miroir \\
$\gamma$ l'angle incident \\
$\epsilon$ l'angle de la source \\ \\ \\ \\
Par la somme des angles intérieurs d'un triangle valant $\pi rad$, \\
$$\gamma = (\pi - \beta - (\pi - \epsilon))$$

$\alpha = \beta - \gamma$ par les angles correspondants
\section[Intersection]{Algorithme d'intersection}

\subsection[Deux droites]{Intersection de deux droites}
Soient \\
$$\begin{cases}
	y = m_1 \cdot x + p_1 \\
	y = m_2 \cdot x + p_2
\end{cases}$$
deux droites sécantes ($m_1 \ne m_2$), résoudre l'équation \\
$$m_1 \cdot x + p_1 = m_2 \cdot x + p_2$$
$$m_1 \cdot x - m_2 \cdot x = p_2 - p_1 $$
$$x \cdot (m_1 - m_2) = p_2 - p_1$$
$$x = \frac{(p_2 - p_1)}{(m_1 - m_2)}$$
nous donne l'abscisse du point d'intersection des deux droites.
Il suffit ensuite de trouver $y$ à l'aide d'une des deux équations.

\subsection[Droite et rectangle]{Intersection d'une droite et d'un rectangle}
Pour trouvez les intersections entre un rectangle et une droite, il suffit de
chercher les intersections entre une droite et les quatre droites qui composent
le rectangle (Cf. ``Intersection de deux droites).

\subsection[Droite et ellipse]{Intersection d'une droite et d'une ellipse}
Soient \\
$$\begin{cases}
	y = m \cdot x + p \\
	\frac{(x - c_x)^2}{{x_{radius}}^2} + \frac{(y - c_y)^2}{{y_{radius}}^2} = 1
\end{cases}$$
une droite et une ellipse quelconque, substituons la droite à l'équation de
l'ellipse
$$\begin{cases}
	y = m \cdot x + p \\
	\frac{(x - c_x)^2}{{x_{radius}}^2} + \frac{((m \cdot x + p) - c_y)^2}{{y_{radius}}^2} = 1
\end{cases}$$
$$\begin{cases}
	y = m \cdot x + p \\
	\frac{(x - c_x)^2 * {y_{radius}}^2}{{x_{radius}}^2 * {y_{radius}}^2} +
	\frac{((m \cdot x + p) - c_y)^2 * {x_{radius}}^2}{{y_{radius}}^2 * {x_{radius}}^2} = 1
\end{cases}$$


\section[Moteur de jeu]{Fonctionnement du moteur}
Le moteur du jeu est articulé autour d'un mécanisme de \textbf{réactions en
chaine} à l'exposition au rayon par les éléments, induite par l'allumage de la source et le
mouvement des miroirs. \\

Lors de l'allumage de la source, celle-ci va appeler la méthode
computeRays( sur la référence du niveau qu'elle contient en attribut. Cette
méthode, la principale du jeu sert à calculer tous les rayons du niveau.
Cette méthode appelle une autre méthode de Level, \texttt{ComputeRay(Ray)} qui elle,
prenant en paramètre un rayon fraichement créé possédant un début une
orientation mais pas encore de fin, va calculer cette dernière. 
C'est cette méthode qui va causer la ``réaction en chaine '' susmentionnée. 
En effet, cette méthode va à partir du rayon reçu en paramètre et de la méthode
getEltsIntrajectory(Ray) (de level également), trouver le premier élément se
trouvant sur la trajectoire du rayon et ainsi lui assigner sa position de fin
avec le point d'intersection trouvé avec cet élément, le rayon sera ensuite
stocké dans le vector prévu à cet effet en attribut de Level. Ensuite va être

\begin{itemize}
	\item[] Cette méthode pourra avoir plusieurs effet:
	\item créer une récursivité croisée en appelant la méthode computeRay(Ray) avec un
nouveau rayon modifié créé à partir du paramètre de reactToray(Ray) créant ainsi
de nouveaux rayons. C'est le cas de 
\begin{itemize}
	\item \texttt{mirror}, qui modifie la direction du rayon,
    \item \texttt{crystal}, qui modifie sa longueur d'onde 
	\item ou possiblement \texttt{lens} si la longueur d'onde du rayon correspond à ces bornes. 
\end{itemize}
    \item Stopper net la progression du rayon, c'est le cas de wall, nuke, dest et lens
    si la longueur d'onde du rayon ne correspond pas à ces bornes.
\end{itemize}

\chapter{Test effectués}
\section{Framework de test}
Le Framework de test utilisé est
``Catch''\textsuperscript{\ref{va}}. Ses avantages
sont :
\begin{itemize}
	\item un simple header est requis,
	\item \textbf{TEST\_CASE} créant un bloc de tests,
	\item \textbf{SECTION} créant un sous bloc de tests,
	\item un ensemble de macros d'assertions sont disponibles :
		\begin{itemize}
			\item\textbf{REQUIRE} qui attend une expression vraie,
			\item\textbf{REQUIRE\_FALSE} qui attend un expression fausse,
			\item\textbf{REQUIRE\_THROWS\_AS} qui attend une erreur de type défini,
			\item\textbf{REQUIRE\_NO\_THROW} qui n'attend pas d'erreur.
		\end{itemize}
\end{itemize} 
\section{Tests unitaire}
Chaque classe a été soumise à une batterie de tests unitaires. Pour se faire,
chacune de ses méthodes s'est vu confirmé son bon fonctionnement au travers de
cas dis ``limites'' et de cas dit ``standards''. \\

Les fichiers sources concernés se situe dans le dossier \path{test/} et peuvent
effectuer en dé commentant la définition de \textbf{\#RUN\_TEST} du fichier
\textbf{main.hpp} disponible à la racine du projet.
\section{Bugs connus}
\begin{center}
	Le programme ne contient aucuns bugs connus et ne présente aucune fuite
	mémoire en dehors de celles induite inévitablement par le framework
	d'interface graphique Qt.

Le modèle a été testé à l'aide de l'outil Valgrind\footnote{voir Annexe~\ref{ref},
Valgrind memory checker}.
\end{center}
\newpage
\chapter{Bonus}

Ensemble des bonus terminés :
\begin{enumerate}
	\item \textbf{les sons}\footnote{voir Annexe~\ref{ref}, Sound bible}  sont disponibles lors 
		\begin{itemize}
			\item de l'activation de la source,
			\item de la désactivation de la source,
			\item de l'activation de la destination,
			\item ou de l'activation d'une bombe.
		\end{itemize}
		Ils ont été ajouté au projet à l'aide du gestionnaires de ressource
		Qt\footnote{voir Annexe~\ref{ref}, Qt ressources system} 
		et activé à l'aide de la méthode statique\footnote{voir Annexe~\ref{ref}, QtMultimedia/QSound}
		\begin{lstlisting}[frame=single,language=C++]
	QSound::play(``:/prefix/alias'');
		\end{lstlisting}
	\item \textbf{les couleurs}\footnote{voir Annexe~\ref{ref}, calcul de longueur d'onde} 
		sont disponibles en fonction de la longueur d'onde du rayon
	\item \textbf{l'icone du logiciel} disponible et a été désigné par
		\href{mailto:39171@heb.be}{\textbf{Kriwin Paul}} sur un support libre d'image d'étoile.
\end{enumerate}
\chapter{Conclusion}


\appendix


Pour conclure, au travers de ce jeu l'algorithmique a pris une grande place. Si
pour le simple utilisateur il parait simple et accessible, pour le développeur
la mise en place a été rude. Du coté graphique, une grande facilité fut d'être
aidé une très bonne documentation de la bibliothèque Qt standard qui se trouve
être un modèle de rédaction de qualité. \\

Un énorme travail de recherche a du être fait au niveau géométrique ainsi qu'au 
niveau des spécifications du langage. Ce dernier a su, pour le binôme que nous 
avons formé durant plus d'un mois, se montrer à la hauteur et à se mettre en 
valeur par des attributs tout à fait intéressant (l'héritage multiple pour n'en
citer qu'un). \\

Il en va de même pour la rédaction de ce document dans un format spécifique et
compliqué (\LaTeX)

Le travail à deux personnes est un enchainement de conflits et d'interactions intellectuelles musclées menant
souvent à la refonte conjointe d'une idée personnelle.
\chapter{Références}\label{ref}

\begin{itemize}
	\item[] l'icone a été dessiné par \href{mailto:39171@heb.be}{\textbf{Kriwin Paul}} sous
		\texttt{Gimp}
		\begin{itemize}
			\item \url{http://www.gimp.org/} consulté \today, \\
		\end{itemize}
	\item[] L'ensemble des sons disponibles dans \path{ressources/sounds}
		proviennent de \texttt{Sound bible}  sous la licence 
		\texttt{Attribution 3.0 License} :
		\begin{itemize}
			\item \url{http://soundbible.com}, consulté \today
			\item \url{https://creativecommons.org/licenses/by/3.0/} consulté
				\today,\\
		\end{itemize}
	\item[] calcul de la longueur d'onde :
		\begin{itemize}
			\item \url{http://www.physics.sfasu.edu/astro/color/spectra.html}
				consulté \today, \\
		\end{itemize}
	\item[] \texttt{Catch Framework} 
		\begin{itemize}
			\item \url{https://github.com/philsquared/Catch} consulté \today,\\
		\end{itemize}
	\item[] \texttt{U.M.L. - Unified Modeling Language} 
		\begin{itemize}
			\item \url{http://www.uml.org/} consulté \today,\\
		\end{itemize}
	\item[] \texttt{Doxygen} 
		\begin{itemize}
			\item \url{http://doxygen.org/} consulté \today,\\
		\end{itemize}
	\item[] \texttt{Plan cartésien} 
		\begin{itemize}
			\item \url{http://www.cslaval.qc.ca/sitsatlll/maths2003/cartesien.html} consulté \today,\\
		\end{itemize}
	\item[] \texttt{Qt Creator} disponible dans sa dernière version sur 
		\begin{itemize}
			\item \url{http://www.qt.io/developers/} consulté le \today,\\
		\end{itemize}
	\item[] \texttt{Catalogue des normes ISO} 
		\begin{itemize}
			\item \url{http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372}
				consulté le \today,\\
		\end{itemize}
	\item[] \texttt{GNU GCC} 
		\begin{itemize}
			\item \url{https://gcc.gnu.org/} consulté le \today,\\
		\end{itemize}
	\item[] \texttt{GNU MakeFile} 
		\begin{itemize}
			\item \url{https://www.gnu.org/software/make/manual/html_node/Makefiles.html} consulté le \today, \\
		\end{itemize}
	\item[] \texttt{HTML} 
		\begin{itemize}
			\item \url{https://fr.wikipedia.org/wiki/Hypertext_Markup_Language} consulté le \today,\\
		\end{itemize}
	\item[] \texttt{CSS} 
		\begin{itemize}
			\item \url{https://fr.wikipedia.org/wiki/Feuilles_de_style_en_cascade} consulté le \today,\\
		\end{itemize}
	\item[] \texttt{CamelCase} 
		\begin{itemize}
			\item \url{https://fr.wikipedia.org/wiki/CamelCase} consulté le \today,\\
		\end{itemize}
	\item[] \texttt{Ellipse}
		\begin{itemize}
			\item \url{https://fr.wikipedia.org/wiki/Ellipse_\%28math\%C3\%A9matiques\%29} consulté le \today,\\
		\end{itemize}
	\item[] \texttt{Droite}
		\begin{itemize}
			\item \url{https://fr.wikipedia.org/wiki/Droite_\%28math\%C3\%A9matiques\%29} consulté le \today,\\
		\end{itemize}
	\item[] \texttt{Point}
		\begin{itemize}
			\item \url{https://fr.wikipedia.org/wiki/Point_\%28g\%C3\%A9om\%C3\%A9trie\%29}
				consulté le \today,\\
		\end{itemize}
	\item[] \texttt{Rectangle}
		\begin{itemize}
			\item \url{https://fr.wikipedia.org/wiki/Rectangle} consulté le
				\today, \\
		\end{itemize}
	\item[]  \texttt{Qt Ressource System}
		\begin{itemize}
			\item \url{http://doc.qt.io/qt-5/resources.html} consulté le
				\today,\\
		\end{itemize}
	\item[] \texttt{QSound}
		\begin{itemize}
			\item \url{http://doc.qt.digia.com/qt-maemo/qsound.html} consulté le
				\today,\\
		\end{itemize}
	\item[] \texttt{GraphicsView}
		\begin{itemize}
			\item \url{http://doc.qt.io/qt-4.8/graphicsview.html} consulté le
				\today, \\
		\end{itemize}
	\item[] \texttt{GraphicsView Framework}
		\begin{itemize}
			\item
				\url{http://doc.qt.io/qt-4.8/graphicsview.html#classes-in-the-graphics-view-framework}
				consulté le \today, \\
		\end{itemize}
	\item[] \texttt{Signals and slots}
		\begin{itemize}
			\item \url{http://doc.qt.io/qt-4.8/signalsandslots.html} consulté le
				\today, \\
		\end{itemize}
	\item[] \texttt{Commandes et règles}
		\begin{itemize}
			\item \path{ressources/other/rules.html},\\
		\end{itemize}
	\item[] \texttt{Valgrind memory checker}
		\begin{itemize}
		\item \url{http://valgrind.org/}, consulté le \today, \\
		\end{itemize}
\end{itemize}


\end{document}
