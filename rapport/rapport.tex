\documentclass[a4paper,11pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[pdftex]{graphicx} 
\usepackage{mathtools}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{pgf, tikz}
\usepackage{url} 
\usepackage[bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={Starlight}, 
pdfauthor={Kriwin Paul, Placentino Simon}, pdfsubject={Starlight},
pdfkeywords={C++, ISO/IEC 14882:2011, Starlight, Projet, ESI}]{hyperref} 
\usetikzlibrary{arrows}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}
\input{./title.tex}
\tableofcontents
\chapter{Introduction}




\chapter[Conventions]{Quelques conventions utilisées}
\section{Langage et compilation}
Ce projet a été bâti à l'aide de \textbf{Qt Creator
5.4}\footnote{\url{http://www.qt.io/developers/}}, pour l'accès à la bibliothèque
graphique, et compilé à l'aide de
\textbf{g++}\footnote{\url{https://gcc.gnu.org/}} dans sa version 4.8 (et
compatible 4.9). La norme \textbf{ISO/IEC
14882:2011}\footnote{\url{http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372}}
, aussi appelée c++11, est celle
utilisée. A cela s'ajoute certains flags\footnote{un flag est un argument de
compilation optionnel} de compilation
\begin{center}
	g++
	\textbf{-std=c++11}\textvisiblespace
	\textbf{--Wextra}\textvisiblespace
	\textbf{--Wall}\textvisiblespace
	\textbf{--pedantic-errors}
\end{center}
\begin{itemize}
	\item \textbf{-std=c++11} pour travailler en c++11,
	\item \textbf{-Wextra} qui nous permet d'avoir des messages d'avertissements,
	\item \textbf{-Wall} qui nous permet d'avoir tous les messages d'avertissements,
	\item \textbf{-pedantic-errors} qui transforme certains warnings\footnote{un
			warning n'empêche pas une bonne compilation mais demande au
		programmeur de vérifier}en erreurs. \\
\end{itemize}
Pour des raisons pratiques, le projet est accompagné d'un fichier de type
\textbf{Makefile}\footnote{\url{https://www.gnu.org/software/make/manual/html_node/Makefiles.html}}
qui s'occupe de
\begin{itemize}
	\item nettoyer le répertoire à l'aide de la commande 
		\begin{center}
			make\textvisiblespace clean
		\end{center}
	\item compiler l'ensemble du projet à l'aide de la commande
		\begin{center}
			make
		\end{center}
\end{itemize}
\newpage
\section{Documentation}
L'ensemble du projet est documenté à l'aide des balises Qt 
\begin{lstlisting}[frame=single,language=C++]
/*!
 * \brief Documentation de la methode enTete
 * \param Description d'un parametre
 * \return Ce qui est retourne
 * \see Renvoie vers une autre documentation
 */
 T enTete(R param);

/*!
 * \brief Documentation de la variable
 */
 T variable;
\end{lstlisting}
et cette documentation est uniquement présente dans les fichiers \textbf{headers}.
La documentation, au format \LaTeX et html, a été généré à l'aide de l'outil
Doxygen\footnote{\url{http://doxygen.org/}} dans sa dernière version
disponible\footnote{1.8.9.1}. Les spécifications de compilations sont disponible
dans le document ``doxyConfig''. La documentation
U.M.L.\footnote{\url{http://www.uml.org/}} a été généré par l'intégration de
l'outil \textbf{graphviz}\footnote{disponible dans les packages GNU/Linux -
Ubuntu standards}.
Cette documentation est disponible dans les dossiers
\begin{center}
\path{documentation/html/index.html} \\
\path{documentation/latex/documentation.pdf} \\
\end{center}
\section{Contenu des fichiers}
Chaque fichier contiendra les en-têtes, ou le code source, d'une seule et unique
classe et d'au maximum un seul namespace. Si la classe ne contient pas au moins
une classe publique, le fichier portera le nom du namespace.
Par exemple, le contenu du fichier hello.hpp peut être ainsi :
\begin{lstlisting}[frame=single,language=C++]
namespace unnamespace {class Hello {};}
\end{lstlisting}
\begin{lstlisting}[frame=single,language=C++]
namespace hello {}
\end{lstlisting}
\begin{lstlisting}[frame=single,language=C++]
class Hello {};
\end{lstlisting}
\section{Nom des fichiers}
Le nom des fichiers est entièrement écrit en minuscule et porte le nom de la
classe, ou du namespace qu'il contient.
\subsection{headers}
Les headers porteront l'extension \textbf{hpp}.
\subsection{sources}
Les fichiers sources porteront l'extension \textbf{cpp}.
\section{Nom des fichiers de test}
Le nom des fichiers de test est composé du nom de la classe ou du namespace
testé suivi de ``test''
\begin{lstlisting}[frame=single]
nuketest.cpp
mirrortest.cpp
\end{lstlisting}
\section{Nom des namespace}
Le nom d'un namespace sera exclusivement en minuscule.
\section{Nom des classes}
Les classes commencent toutes par une majuscule pour continuer, ensuite, en
CamelCase
\begin{lstlisting}[frame=single,language=C++]
class UneBonneClasse{};
class uneMauvaiseclasse{};
\end{lstlisting}
\section{Nom des variables}
Toutes les variables sont écrites en
\textbf{camelCase}\footnote{\url{https://fr.wikipedia.org/wiki/CamelCase}}
\begin{lstlisting}[frame=single,language=C++]
T uneBonneVariable;
T UneMauvaiseVariable;
T uneautreMauvaisevariable;
\end{lstlisting}
et possède des noms le plus explicite possible
\begin{lstlisting}[frame=single,language=C++]
T nb; // OK
T n; // NOK
T waveLength; // OK
\end{lstlisting}
Les variables de classes possèdent le même nom que le paramètre de constructeur
qui l'initialisera. Le langage nous donne la possibilité de désambiguïser
l'utilisation de ces variables à l'aide de 
\begin{lstlisting}[frame=single,language=C++]
T var;
this->var;
\end{lstlisting}
et de la liste d'initialisation
\begin{lstlisting}[frame=single,language=C++]
UneClasse::UneClasse(T param) : param{param} {}
\end{lstlisting}
\chapter[Les classes]{Présentation succincte des classes}
\section[Les objets géométriques]{geometry}

\subsection[Ellipse]{ellipse.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[gray, very thin] (-2, 0) grid (2, 2);
		\draw[red](0, 0) -- (0, 1);
		\draw[blue](2, 1) -- (0, 1);
		\draw (0,1) ellipse (2cm and 1cm);
	\end{tikzpicture} 
\end{center}
Une ellipse est un objet géométrique à deux dimensions représentée par
une courbe plane fermée obtenu par découpe d'un cône sur un plan. Si ce dernier
est perpendiculaire à l'axe du cône, l'ellipse sera alors un cercle.
Éléments caractéristiques d'une ellipse :
\begin{itemize}
	\item une coordonnée cartésienne de son centre,
	\item une distance séparant le centre de l'intersection avec une parallèle à
		l'axe des ordonnées tangente à l'ellipse voulue,
	\item une distance séparant le centre de l'intersection avec une parallèle à
		l'axe des abscisse tangente à l'ellipse voulue.
\end{itemize}
Ces éléments nous permettront de tracer une ellipse selon cette équation :
$$\frac{(x - c_x)^2}{{x_{radius}}^2} + \frac{(y - c_y)^2}{{y_{radius}}^2} = 1$$

Cette classe peut tout à fait être instancié en objet géométrique elliptique
et possède des méthodes d'interactions avec une droite\footnote{L'algorithme
	est disponible dans la section du même nom ou dans la documentation
accompagnant le projet}.
\begin{lstlisting}[frame=single,language=C++]
Ellipse::getIntersectionsPoints(Line);
\end{lstlisting}
Dans le contexte présent, certains éléments du jeu seront des ellipse par le 
phénomène d'héritage mis en place dans le paradigme orienté objet de
C++\footnote{\url{http://www.tutorialspoint.com/cplusplus/cpp_object_oriented.htm}}

\subsection[Droite]{line.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[gray, very thin] (0,0) grid (3,3);
		\draw[dashed] (-1, -1) -- (0, 0);
		\draw (0,0) -- (3, 3);
		\draw[dashed] (3,3) -- (4, 4);
	\end{tikzpicture} 
\end{center}
Une droite est une ligne sans épaisseur, rectiligne et infinie dans le plan. 
Pour exister, une droite aura besoin :
\begin{itemize}
	\item d'un coefficient angulaire $m = \frac{\Delta y}{\Delta x}$
		représentant la distance à parcourir sur l'axe des ordonnées pour une unité de
		distance sur l'axe des abscisses.
	\item d'un terme indépendant $p = \frac{y}{m \cdot x}$ représentant le décalage de chaque point
		sur l'axe des ordonnées,
	\item ou de deux points de coordonnées dans le plan,
	\item ou d'un point de coordonnées dans le plan et d'un coefficient
		angulaire.
\end{itemize}
Ces éléments nous permettent de tracer une droite selon cette équation :
$$ y = m \cdot x + p $$

\subsection[Rectangle]{rectangle.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw (1, 1) -- (4, 1);
		\draw (4, 1) -- (4, 2.5);
		\draw (4, 2.5) -- (1, 2.5);
		\draw (1, 2.5) -- (1, 1);
	\end{tikzpicture} 
\end{center}
Un rectangle est une forme géométrique à 4 segments de droite\footnote{Un
	segment de droite est une partie de droite délimitée par deux points non
confondus} 
parallèle deux à deux.Ceux-ci vont donc former 4 angles droit ($\frac{\pi}{2} rad$)
Cette forme peut être représentée par :
\begin{itemize}
	\item la coordonnée du coin supérieur gauche $Sg = (x, y)$
	\item la grandeur des deux segments formant un angle de $\frac{\pi}{2} rad$
		en ce point $hauteur$ et $largeur$.
\end{itemize}

Ainsi, il sera aisé de déterminer la position des autres coins 
\begin{itemize}
	\item $Sd = (Sg_x + largeur, Sg_y)$
	\item $Ig = (Sg_x , Sg_y + hauteur)$
	\item $Id = (Sg_x + largeur, Sg_y + hauteur)$
\end{itemize}

Il existe plusieurs cas particuliers de droite :
\begin{itemize}
	\item une droite parallèle à l'axe des ordonnées qui aura pour équation \\
		$x = a,$ $a \in \mathbb{R}$,
	\item une droite parallèle à l'axe des abscisses qui aura pour équation \\
		$y = b,$ $b \in \mathbb{R}$,
\end{itemize}
\subsection[Point]{point.hpp}
Un point est un objet mathématique permettant de situer un élément dans un plan
ou dans l'espace. Dans notre cas, plus spécifiquement dans un plan à deux
dimensions. Celui-ci peut-être représenté de plusieurs manières dans le plan 
cartésien\footnote{\url{http://www.cslaval.qc.ca/sitsatlll/maths2003/cartesien.html}} : 
\begin{itemize}
	\item sous la forme d'une coordonnées cartésienne à l'aide de 
		\begin{itemize}
			\item une origine,
			\item deux vecteurs partant de cette origine et perpendiculaires,
				$$P = (\vec{x}, \vec{y})$$
		\end{itemize}
	\item et sous la forme d'une coordonnée polaire à l'aide de
		\begin{itemize}
			\item une origine,
			\item une coordonnée radiale $r$,
			\item une coordonnée angulaire $\alpha$.
		\end{itemize}
\end{itemize}
\subsection[Utilitaire]{utilities.hpp}
Le namespace ``utilities'' mis en place ici est un ensemble de fonctions et valeurs
constantes spécifiquement définies pour les calculs intervenant dans le projet.

\subsubsection{constantes :}
\begin{description}
	\item[PI] est un approximation de $\pi$ sur 26 décimales,
	\item[PI\_2] est une approximation de $\frac{\pi}{2}$ sur 26 décimales,
	\item[PI\_4] est une approximation de $\frac{\pi}{4}$ sur 26 décimales,
	\item[EPSILON] est une marge d'erreur de $10^{-7}$,
	\item[INF] représente un nombre dit ``infini'' dans le milieu informatique.
\end{description}
\subsubsection{fonctions :}
\begin{lstlisting}[title=Resolution d'équation du second degre,frame=single,language=C++]
utilitaire::secondDegreeEquationSolver
\end{lstlisting}
\begin{lstlisting}[title=Transforme un angle exprime en radian en un angle
exprime en degres,frame=single,language=C++]
utilitaire::angleAsDegree
\end{lstlisting}
\begin{lstlisting}[title=Permet de tester l egalite ou l inegalite entre deux 
nombre reels a un Epsilon d erreur,frame=single,language=C++]
utilitaire::equals
utilitaire::greaterOrEquals
utilitaire::lessOrEquals
\end{lstlisting}
\begin{lstlisting}[title=Permet de trouver le coefficiant angulaire a partir de deux points'',frame=single,language=C++]
utilitaire::slopeFromPoints
\end{lstlisting}
\begin{lstlisting}[title=Permet de trouver la valeur tangante d'un angle 
	en radian mais aussi de retourner une valeur particuliere pour la tangante de
$\pi/2$,frame=single,language=C++]
utilitaire::tan
\end{lstlisting}
\begin{lstlisting}[title=Permet de savoir si $\alpha$ vaut  $\frac{\pi}{2} + n *
\pi\ n \in \mathbb{N}$,frame=single,language=C++]
utilitaire::isHalfPiPlusNPi
\end{lstlisting}
\section[Les éléments]{éléments}
\subsection[Element]{element.hpp}
Cette classe, abstraite et donc non instanciable, représente un élément du jeu
lié à un, et un seul, niveau du jeu. Cette classe permet donc d'établir une
communication entre les différents éléments du niveau et le niveau lui-même à
travers un référencement de ce dernier.
Par le phénomène d'héritage, chaque élément pourra établir sa manière propre de
réagir avec le niveau en lui exprimant : 
\begin{itemize}
	\item ses points d'intersection avec un rayon si il lui sont demandés,
		\begin{lstlisting}[language=C++]
		Element::includeRay(Ray);
		\end{lstlisting}
	\item les actions à effectuer si un contact avec le rayon a eu lieu.
		\begin{lstlisting}[language=C++]
		Element::reactToRay(Ray);
		\end{lstlisting}
\end{itemize}
Il sera donc aisé pour le niveau de gérer les collisions des éléments de manière
anonyme et optimale (cf Niveau).
\subsection[Cristal]{crystal.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[fill=green] (0,0) ellipse (2cm and 2cm);
		\draw[yellow] (-4, 0) -- (-2, 0);
		\draw[red] (2, 0) -- (3, 0);
	\end{tikzpicture} 
\end{center}
Cette classe est, par héritage, un élément ainsi qu'une ellipse. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et communique avec
le niveau auquel il est lié. Le cristal modifie la longueur d'onde d'un rayon
qui le traverse. D'un point de vue technique, il en relève donc d'un choix
personnel, il ne va pas amplifier le rayon entrant à partir de sa sortie mais 
arrêtera ce rayon et en créera un nouveau qui, lui, aura subit l'action du cristal.
\subsection[Destination]{dest.hpp}
Cette classe est, par héritage, un élément ainsi qu'un rectangle. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. La destination est le but du jeu
et l'atteindre terminera automatiquement la partie sur une victoire.
\subsection[Lentille]{lens.hpp}
\begin{center}
	\begin{tikzpicture}
		\draw[fill=blue,blue] (0,0) ellipse (2cm and 1cm);
		\draw[red] (-4, 0) -- (-2, 0);
		\draw[red, dashed] (2, 0) -- (3, 0);
	\end{tikzpicture} 
\end{center}
Cette classe est, par héritage, un élément ainsi qu'un rectangle. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. La lentille est un éventuel
obstacle à un rayon puisqu'il ne le laissera passer que si la longueur d'onde de
ce dernier respecte le critère
$$lens_{min} \leq ray_{\alpha} \leq lens_{max}$$

Deux issues sont alors possible :
\begin{itemize}
	\item la longueur d'onde entre dans l'intervalle et le rayon est renouvelé
		après la lentille
	\item ou elle ne rentre pas dans l'intervalle défini et le rayon sera terminé par
		la lentille
\end{itemize}
et ce même si le rayon tiré est tangent à la lentille. En effet, si la droite
représentant le rayon est tangent à l'ellipse représentant la lentille c'est
qu'un point d'intersection existe entre les deux. Il est donc de ce point d'agir
comme l'aurait fait l'entière lentille à tout autre point même si cette
réaction particulière peut être discutable. 

\subsection[Miroir]{mirror.hpp}
Cette classe est, par héritage, un élément ainsi qu'une droite. Le miroir peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communiquer avec le niveau auquel il est lié. Le miroir est, plus précisément,
un segment de droite délimité par deux points. Puisque le miroir effectue une
rotation autour d'un point $p \in mirroir$, il n'est pas directement
délimité par ses deux extrémités mais bien par sa longueur, son angle, la position
absolue (cartésienne) et relative (distance par rapport à une extrémité)
de son point de rotation qui définissent, dynamiquement, ses points délimiteurs.
Pour trouver les deux points il suffit de :
\begin{enumerate}
	\item extrémité gauche = ($x_{pivot}$ - position absolue, $y_{pivot}$)
	\item extrémité droite = ($x_{gauche}$ + taille du segment, $y_{pivot}$)
	\item rotation des deux extrémité autour du point de pivot.
\end{enumerate}
\subsection[Bombe]{nuke.hpp}
Cette classe est, par héritage, un élément ainsi qu'une ellipse. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. La bombe est une ellipse
particulière puisqu'elle possède un $x_{radius} = y_{radius}$ lui donnant comme
caractéristique d'être un cercle. Cet objet circulaire est l'objet à éviter lors
d'une partie puisqu'il amène directement à la fin d'une partie.

\subsection[Rayon]{ray.hpp}
Cette classe est, par héritage, une droite. Ce rayon représente l'ensemble des
points parcouru par un rayon laser et subit les interactions de son
environnement comme dans la vie réelle :
\begin{itemize}
	\item il sera reflété par un miroir selon le principe de réflexion
		$$\alpha_{i} = \alpha_{r}$$,
	\item il sera arrêté par les objets opaques (murs, source, destination).
\end{itemize}

Le rayon déclenche les réactions des éléments du jeu via la méthode
``reactToRay'' des héritiers d'Element.

\subsection[Source]{source.hpp}
Cette classe est, par héritage, un élément ainsi qu'un rectangle. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. La source est le point d'émission
du tout premier rayon du jeu selon un sens et une direction définis par l'angle
d'émission, qui lui est propre, depuis un point donné.

\subsection[Mur]{wall.hpp}
Cette classe est, par héritage, un élément ainsi qu'une droite. Il peut donc
être modéliser graphiquement, entant que cette dernière, dans le plan et
communique avec le niveau auquel il est lié. Le mur est défini par deux points
qui en font un segment de droite. Il est un objet fixe du jeu qui arrête un
rayon et lui défini un point qui le transforme en segment de droite.

\subsection[Niveau]{level.hpp}
\subsection[Createur de niveau]{levelfactory.hpp}
Le créateur de niveau est un ``namespace'' de méthodes qui va s'occuper de lire
les données des éléments dans un fichier. 
Pour ce faire, il s'occupera de lire chaque type d'objet selon des règles
différentes :
\begin{lstlisting}[frame=single,language=C++]
levelFactory::getSource;
levelFactory::getDestination;
levelFactory::getCrystal;
levelFactory::getLens;
levelFactory::getNuke;
levelFactory::getWall;
levelFactory::getMirror;
\end{lstlisting}
\section[L'exception]{exception}
\subsection[Exception Starlight]{starlightexception.hpp}
Il est nécessaire, pour bon nombre des classes créées, de valider les arguments passés en
paramètre dans le but de ne pas produire d'objets incohérents par rapport à
l'analyse préalable du travail à fournir. Pour ce faire, des exceptions doivent
être levées quand une instanciation créera un objet non désiré. 
Cette classe hérite de std::exception appartenant à la librairie standard. Elle n'a aucune
capacité supplémentaire mise à part être spécifique à ce projet. \\ \\

Les différentes classes pouvant lever cette exception sont :
\begin{description}
	\item[crystal] si la taille de son rayon ne lui permet pas d'exister dans le
		plan,
	\item[lens] si son intervalle de longueur d'onde n'est pas cohérent,
	\item[level] si ses dimensions ne lui permettent pas d'exister dans le plan,
	\item[mirror] si ses dimensions ne lui permettent pas d'exister dans le
		plan, si sa position ou son angle n'entre pas dans les limites imposées,
	\item[nuke] si la taille de son rayon ne lui permet pas d'exister dans le
		plan,
	\item[ray] si sa longueur d'onde n'entre pas dans l'intervalle cohérent
		imposé,
	\item[source] si sa longueur d'onde n'entre pas dans l'intervalle cohérent
		imposé,
	\item[wall] si ses points déterminants ne lui permettent pas d'exister dans
		le plan,
	\item[ellipse] si ses dimensions ne lui permettent pas d'exister dans le
		plan,
	\item[rectangle] si ses dimensions ne lui permettent pas d'exister dans le
		plan.
\end{description}
\section[Les objets visuels]{view}


\chapter[Structure du programme]{Structure générale du programme}



\chapter[Algorithmes]{Détail des algorithmes utilisés}
\section[Réflexion]{Algorithme de réflexion}
\input{./reflexion.tex} \\
$\alpha$ l'angle du nouveau rayon \\
$\beta$ l'angle du miroir \\
$\gamma$ l'angle incident \\
$\epsilon$ l'angle de la source \\ \\
$\gamma = (\pi - \beta - (\pi - \epsilon))$ par la somme des angles intérieurs d'un
triangle valant $\pi rad$, \\
$\alpha = \beta - \gamma$ par les angles correspondants
\section[Intersection]{Algorithme d'intersection}
\subsection[Deux droites]{Intersection de deux droites}
\subsection[Droite et rectangle]{Intersection d'une droite et d'un rectangle}
\subsection[Droite et ellipse]{Intersection d'une droite et d'une ellipse}



\chapter{Test effectués}
\section{Framework de test}
Le Framework de test utilisé est
``Catch''\footnote{\url{https://github.com/philsquared/Catch}}. Ses avantages
sont :
\begin{itemize}
	\item un simple header est requis,
	\item \textbf{TEST\_CASE} créant un bloc de tests,
	\item \textbf{SECTION} créant un sous bloc de tests,
	\item un ensemble de macros d'assertions sont disponibles :
		\begin{itemize}
			\item\textbf{REQUIRE} qui attend une expression vraie,
			\item\textbf{REQUIRE\_FALSE} qui attend un expression fausse,
			\item\textbf{REQUIRE\_THROWS\_AS} qui attend une erreur de type défini,
			\item\textbf{REQUIRE\_NO\_THROW} qui n'attend pas d'erreur.
		\end{itemize}
\end{itemize} 
\section{Tests unitaire}
Chaque classe a été soumise à une batterie de tests unitaires. Pour se faire,
chacune de ses méthodes s'est vu confirmé son bon fonctionnement au travers de
cas dis ``limites'' et de cas dit ``standards''. \\

Les fichiers sources concernés se situe dans dossier ``test/'' du projet et
peuvent être effectués sous certaines condition\footnote{en effet, il faudra au
	préalable rendre la méthode main de l'application inutilisable pour 
permettre aux tests de s'appliquer exclusivement}.
\chapter{Conclusion}


\appendix


\chapter{Références}


\end{document}
